# -*- coding: utf-8 -*-
"""PCOSprediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OIKiX7FjYQWYo7YfGh6N9viOUlOTxNDE
"""

from google.colab import drive
drive.mount("/content/drive")

import os
import pandas as pd
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array
from tensorflow.keras.applications import VGG16
from tensorflow.keras.applications import Xception
from tensorflow.keras.models import Sequential
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.layers import Dense,GlobalAveragePooling2D, Flatten, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.applications.vgg16 import preprocess_input
import cv2
from sklearn.model_selection import train_test_split

# Load Excel file containing image names and labels
xlsx_path = '/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/class_label.xlsx'
image_path = '/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/images/'
df=pd.read_excel(xlsx_path)
def preprocess_ultrasound_image(image_path):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("Image not found:", image_path)
        return None

    img = cv2.equalizeHist(img)
    img = cv2.resize(img, (224,224), interpolation=cv2.INTER_AREA)
    img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)  # Convert to RGB format
    img = img.astype('float32') / 255.0  # Normalize pixel values
    return img

X = []
for img_name in df['imagePath']:
    img_path = os.path.join('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/images', img_name)
    preprocessed_img = preprocess_ultrasound_image(img_path)
    X.append(preprocessed_img)
X = np.array(X)

sample_images = df.sample(5)
# Visualize raw images before preprocessing
plt.figure(figsize=(15, 16))
for i, (_, row) in enumerate(sample_images.iterrows()):
    img_path = os.path.join('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/images', row['imagePath'])
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    plt.subplot(2, 10, i+1)
    plt.imshow(img, cmap='gray')
    plt.title('Before Preprocessing')
    plt.axis('off')

# Visualize preprocessed images
num_images = len(X)
num_rows = 3  # Adjust as needed
num_columns = 7  # Adjust as needed
for i, preprocessed_img in enumerate(X):
    plt.figure(figsize=(15, 6))
    plt.subplot(num_rows, num_columns, i % (num_rows * num_columns) + 1)
    plt.imshow(preprocessed_img, cmap='gray')
    plt.title('After Preprocessing')
    plt.axis('off')
    plt.show()

# Extract labels from the DataFrame
y = df['Healthy'].values

# Split data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten

# Load pre-trained Xception model
base_model = keras.applications.Xception(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.summary()

# Set layers in the base model as non-trainable
for layer in base_model.layers:
    layer.trainable = False

# Build your model on top of the pre-trained base model
model = Sequential([
    base_model,
    Flatten(),
    Dense(256, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

model.summary()

print(f'X_train type: {type(X_train)}')
print(f'y_train type: {type(y_train)}')

# # Freeze convolutional layers
# for layer in base_model.layers:
# layer.trainable = False
# # Build model
# model = Sequential([
#     base_model,
#     Flatten(),
#     Dense(256, activation='relu'),
#     Dropout(0.5),
#     Dense(1, activation='sigmoid')
# ])
# # Original batch size
# batch_size = 32

# # Reducing batch size
# new_batch_size = 16

# # Assuming you have a dataset object named 'dataset' and a model named 'model'
# # Create a new dataset with the reduced batch size
# smaller_dataset = df.batch(new_batch_size)

X_train = np.array(X_train)
y_train = np.array(y_train)

# Compile model
model.compile(optimizer=Adam(learning_rate=0.0001), loss='binary_crossentropy', metrics=['accuracy'])

# Train model
model.fit(X_train, y_train, batch_size=8, epochs=5, validation_data=(X_val, y_val))

# Evaluate model
loss, accuracy = model.evaluate(X_val, y_val)
print(f'Validation Accuracy: {accuracy*100:.2f}%')

# Save model
model.save('pcos_detection_Xception_model.h5')

import os
import cv2

# Path to the directory containing test images
test_data_dir = '/content/drive/MyDrive/PCOSGen-test/images'

# Function to identify and remove corrupted images
def remove_corrupted_images(directory):
    corrupted_images = []
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        try:
            # Attempt to read the image using OpenCV
            img = cv2.imread(file_path)
            if img is None:
                # Image could not be read
                corrupted_images.append(filename)
        except Exception as e:
            # Error occurred while reading the image
            print(f"Error reading image {filename}: {str(e)}")
            corrupted_images.append(filename)

    # Remove corrupted images from the directory
    for filename in corrupted_images:
        file_path = os.path.join(directory, filename)
        os.remove(file_path)
        print(f"Removed corrupted image: {filename}")

# Call the function to remove corrupted images from the test dataset directory
remove_corrupted_images(test_data_dir)

# Load your dataset and split it into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#check for missing values
print(pd.isnull(X_train).sum().sum())
print(pd.isnull(X_test).sum().sum())

#reshape the data
X_train_reshaped = X_train.reshape(X_train.shape[0], -1)
X_test_reshaped = X_test.reshape(X_test.shape[0], -1)

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.ensemble import StackingClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from xgboost import XGBClassifier
from keras.models import load_model
from sklearn.base import BaseEstimator
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline

# Load your dataset and split it into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Load the pre-trained model
pcosvgg_model = load_model("/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/pcos_detection_Xception_model.h5")
pcosvgg_estimator = make_pipeline(StandardScaler(with_mean=False), pcosvgg_model)

# Define the base models for stacking
base_models = [
    ('pcosvgg', pcosvgg_estimator),
    ('rf', RandomForestClassifier(n_estimators=100)),
    ('gb', GradientBoostingClassifier(n_estimators=100)),
    ('logreg', LogisticRegression(max_iter=1000))
]

# Define the meta learner
meta_learner = XGBClassifier()

# Create the stacking classifier
stacking_classifier = StackingClassifier(estimators=base_models, final_estimator=meta_learner)

# Train the ensemble classifier
stacking_classifier.fit(X_train_reshaped, y_train)

# Evaluate the ensemble classifier
y_pred = stacking_classifier.predict(X_test_reshaped)
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

#Investigate the StandardScaler:
print(pcosvgg_estimator.get_params())

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.preprocessing import image

# Load your trained model
model = tf.keras.models.load_model('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/pcos_detection_Xception_model.h5')

# Function to preprocess an image for prediction
def preprocess_image(image_path):
    img = image.load_img(image_path, target_size=(224, 224))  # Adjust target_size according to your model's input size
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# Function to make predictions and plot interpretation
def plot_interpretation(image_path):
    img_array = preprocess_image(image_path)
    predictions = model.predict(img_array)

    # Get class labels
    class_labels = ['No PCOS', 'PCOS']

    # Plot image
    plt.imshow(image.load_img(image_path))
    plt.axis('off')
    plt.show()

    # Plot interpretation
    plt.bar(class_labels, predictions[0])
    plt.ylabel('Probability')
    plt.title('Prediction')
    plt.show()

# Provide the path to the image you want to interpret
image_path = '/content/drive/MyDrive/PCOSGen-test/images/image10012.jpg'  # Adjust the path to your image
plot_interpretation(image_path)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
from tensorflow.keras.preprocessing import image
import tensorflow as tf

# Load your trained model
model = tf.keras.models.load_model('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/pcos_detection_Xception_model.h5')

# Function to preprocess an image for prediction
def preprocess_image(image_path):
    img = image.load_img(image_path, target_size=(224, 224))  # Adjust target_size according to your model's input size
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# List of paths to the sample images
image_paths = ['/content/drive/MyDrive/PCOSGen-test/images/image10012.jpg', '/content/drive/MyDrive/PCOSGen-test/images/image10006.jpg', '/content/drive/MyDrive/PCOSGen-test/images/image10007.jpg']

# List of true labels for the sample images (assuming binary classification)
true_labels = [0, 1, 0]  # Adjust these labels based on your dataset

# Function to make predictions on sample data
def predict_on_sample_data(image_paths):
    predictions = []
    for image_path in image_paths:
        img_array = preprocess_image(image_path)
        prediction = model.predict(img_array)
        predictions.append(prediction[0][0])  # Assuming the positive class index is 0
    return predictions

# Make predictions on sample data
predicted_probs = predict_on_sample_data(image_paths)

# Compute ROC curve and AUC
fpr, tpr, thresholds = roc_curve(true_labels, predicted_probs)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import precision_recall_curve, average_precision_score
from tensorflow.keras.preprocessing import image
import tensorflow as tf

# Load your trained model
model = tf.keras.models.load_model('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/pcos_detection_Xception_model.h5')

# Function to preprocess an image for prediction
def preprocess_image(image_path):
    img = image.load_img(image_path, target_size=(224, 224))  # Adjust target_size according to your model's input size
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# List of paths to the sample images
image_paths = ['/content/drive/MyDrive/PCOSGen-test/images/image10012.jpg', '/content/drive/MyDrive/PCOSGen-test/images/image10006.jpg', '/content/drive/MyDrive/PCOSGen-test/images/image10007.jpg']

# List of true labels for the sample images (assuming binary classification)
true_labels = [0, 1, 0]  # Adjust these labels based on your dataset

# Function to make predictions on sample data
def predict_on_sample_data(image_paths):
    predictions = []
    for image_path in image_paths:
        img_array = preprocess_image(image_path)
        prediction = model.predict(img_array)
        predictions.append(prediction[0][0])  # Assuming the positive class index is 0
    return predictions

# Make predictions on sample data
predicted_probs = predict_on_sample_data(image_paths)

# Compute precision-recall curve and average precision
precision, recall, _ = precision_recall_curve(true_labels, predicted_probs)
average_precision = average_precision_score(true_labels, predicted_probs)

# Plot precision-recall curve
plt.figure()
plt.step(recall, precision, color='b', alpha=0.2, where='post')
plt.fill_between(recall, precision, step='post', alpha=0.2, color='b')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.ylim([0.0, 1.05])
plt.xlim([0.0, 1.0])
plt.title('Precision-Recall curve: AP={0:0.2f}'.format(average_precision))
plt.show()

import os
import cv2
import pandas as pd
import numpy as np
from tensorflow.keras.models import load_model

# Path to the directory containing test images
test_data_dir = '/content/drive/MyDrive/PCOSGen-test/images'

# Load the trained Xception model
pcos_detection_Xception_model = load_model('pcos_detection_Xception_model.h5')

# Initialize lists to store image names and predictions
image_names = []
predictions = []

# Function to make predictions on test images
def predict_test_images(directory):
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        try:
            # Read and preprocess the image
            img = cv2.imread(file_path)
            if img is None:
                print(f"Error reading image {filename}: Image is None")
                continue
            img = cv2.resize(img, (224, 224))  # Resize image to match input_shape used during training
            img = img / 255.0  # Normalize pixel values (assuming model was trained with normalized data)
            img = np.expand_dims(img, axis=0)  # Add batch dimension

            # Make prediction using the model
            prediction = model.predict(img)[0][0]  # Assuming model outputs a single value (e.g., for binary classification)

            # Convert prediction to binary (1 or 0)
            prediction_binary = 1 if prediction >= 0.5 else 0

            # Append image name and prediction to lists
            image_names.append(filename)
            predictions.append(prediction_binary)

        except Exception as e:
            # Error occurred while processing the image
            print(f"Error processing image {filename}: {str(e)}")

# Call the function to make predictions on test images
predict_test_images(test_data_dir)

# Create a DataFrame to store image names and predictions
data = {'Image Name': image_names, 'Prediction': predictions}
df = pd.DataFrame(data)

# Path to the Excel file to save the results
output_excel_file = 'predictions.xlsx'

# Save DataFrame to Excel file
df.to_excel(output_excel_file, index=False)

print(f"Predictions saved to {output_excel_file}")

# Save model in HDF5 format
model.save('/content/drive/MyDrive/PCOSGen-train/PCOSGen-train/pcos_detection_Xception_model.h5')

